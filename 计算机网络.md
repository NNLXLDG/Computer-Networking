# 第一章 计算机网络导论

## 1.1 互联网概述
### 1.1.1 互联网的组成要素
- 基础设施视角：
  - 数十亿互联的计算设备（主机/端系统）
  - 通信链路（光纤、铜缆、无线电、卫星）
  - 分组交换设备（路由器和交换机）
  - 由多个组织管理的网络集合

### 1.1.2 服务视角
- 为应用层服务提供基础设施：
  - Web、流媒体、视频会议、电子商务等
  - 提供分布式应用的编程接口（API）

### 1.1.3 互联网协议
- 定义：
  - 控制消息收发规则的集合
  - 规定消息格式、顺序和响应动作
- 常见协议示例：
  - HTTP, TCP, IP, WiFi, 4G/5G, Ethernet
- 标准化组织：
  - IETF（互联网工程任务组）
  - RFC（请求评论）文档体系

## 1.2 网络边缘

### 1.2.1 接入网络类型
- 住宅接入：
  - DSL（数字用户线）：利用电话线，24-52Mbps下行
  - HFC（混合光纤同轴）：40Mbps-1.2Gbps下行
- 企业接入：
  - 以太网（100Mbps-10Gbps）
  - WiFi（802.11标准）
- 移动接入：
  - 蜂窝网络（4G/5G）
  - WiFi热点

### 1.2.2 物理介质
- 有线介质：
  - 双绞线（Cat5/Cat6）
  - 同轴电缆
  - 光纤（10-100Gbps）
- 无线介质：
  - 无线电频谱（2.4GHz/5GHz）
  - 微波传输
  - 卫星通信

## 1.3 网络核心

### 1.3.1 分组交换
- 工作原理：
  - 存储转发机制
  - 统计复用共享带宽
- 关键参数：
  - 传输延迟 = 数据包大小/链路速率（L/R）
  - 排队与丢包现象

### 1.3.2 电路交换
- 特点：
  - 专用端到端连接
  - 频分复用（FDM）和时分复用（TDM）
  - 资源独占，无带宽竞争

### 1.3.3 交换技术对比
| 特性        | 分组交换          | 电路交换        |
|-----------|---------------|-------------|
| 资源分配      | 动态共享         | 静态预留       |
| 适合流量类型    | 突发数据         | 恒定流量       |
| 带宽利用率     | 高             | 低           |
| 服务质量保证    | 无             | 有           |

## 1.4 互联网结构

### 1.4.1 分层架构
1. 接入层：终端用户网络（家庭/企业）
2. 区域ISP：本地服务提供商
3. 国家ISP：骨干网络运营商
4. 内容提供商网络（Google等自建网络）

### 1.4.2 互联机制
- IXP（互联网交换中心）：
  - 实现不同ISP之间的对等互联
- 对等连接协议：
  - 商业协议规范网络互连

## 1.5 网络性能

### 1.5.1 关键指标
- 延迟组成：
  - 传输延迟
  - 传播延迟
  - 处理延迟
  - 排队延迟
- 吞吐量：
  - 瓶颈链路决定端到端吞吐量
- 丢包率：
  - 缓冲区溢出导致数据丢失


### 1.5.2 数据包延迟类型
- **处理延迟**（<1μs）：
  - 错误检查
  - 路由决策
- **排队延迟**：
  - 取决于路由器拥塞程度
  - 流量强度=La/R（a:到达率，L:包长，R:链路速率）
    - La/R→1时延迟显著增大
    - La/R>1时出现无限延迟（理论模型）
- **传输延迟**：
  - 计算公式：d<sub>trans</sub> = L/R
  - L: 数据包长度(bit)，R: 链路速率(bps)
- **传播延迟**：
  - 计算公式：d<sub>prop</sub> = d/s
  - d: 物理距离，s: 传播速度(≈2×10<sup>8</sup>m/s)

### 1.5.3 延迟类比模型
- **车队过收费站模型**：
  - 收费站服务时间对应传输延迟
  - 公路行驶时间对应传播延迟
  - 关键启示：传输延迟与数据包长度正相关，传播延迟与物理距离正相关

### 1.5.4 真实网络延迟测量
- **Traceroute工具**：
  - 通过TTL递增探测路径
  - 显示路径中每个节点的三次RTT值
  - 示例结果分析：
    ```bash
    8  62.40.103.253  104ms  # 跨洋链路延迟突增
    19 fantasia.eurecom.fr 132ms  # 端到端总延迟
    ```

## 1.6 网络安全基础

### 1.6.1 主要攻击类型
| 攻击类型        | 原理描述                     | 防御措施                 |
|---------------|--------------------------|----------------------|
| 数据包嗅探        | 利用共享介质截取明文数据            | 加密传输（HTTPS, VPN）      |
| IP地址欺骗       | 伪造源地址发起攻击               | 入口过滤（RFC 2827）        |
| DDoS攻击       | 僵尸网络淹没目标资源              | 流量清洗、黑洞路由            |
| 中间人攻击        | 劫持会话窃取信息                | 数字证书认证、双向认证           |

### 1.6.2 安全防御体系
1. **认证机制**：
   - SIM卡物理认证（蜂窝网络）
   - 数字证书（TLS/SSL）
2. **加密传输**：
   - 对称加密（AES）
   - 非对称加密（RSA）
3. **完整性保护**：
   - HMAC哈希校验
   - 数字签名（ECDSA）
4. **访问控制**：
   - 防火墙状态检测
   - ACL访问控制列表

## 1.7 协议分层模型
- 各层独立发展
- 下层为上层提供服务
- 协议栈实例：
  - TCP/IP五层模型（物理层→应用层）


### 1.7.1 TCP/IP五层模型
| 层级       | 协议示例                  | 数据单元     | 关键功能               |
|----------|-----------------------|----------|--------------------|
| 应用层      | HTTP, DNS, SMTP       | 消息/报文    | 实现具体应用服务           |
| 传输层      | TCP, UDP              | 段        | 端到端通信质量控制          |
| 网络层      | IP, ICMP              | 数据报      | 路由选择与逻辑寻址          |
| 数据链路层    | Ethernet, 802.11      | 帧        | 介质访问控制与物理地址        |
| 物理层      | RJ45, 无线电频谱          | 比特流      | 信号编码与物理传输          |


### 1.7.2 封装过程图解
1. **应用层**：原始数据（如HTTP请求）
2. **传输层**：添加TCP头 → 段（源/目的端口，序列号）
3. **网络层**：添加IP头 → 数据报（源/目的IP，TTL）
4. **链路层**：添加以太网头 → 帧（MAC地址，FCS校验）
5. **物理层**：转换为电信号/光信号

```
[HTTP数据]
↓ +TCP头 → [TCP段]
↓ +IP头  → [IP数据报] 
↓ +以太网头 → [以太网帧]
↓ 比特流传输
```

## 1.8 互联网发展简史

### 1.8.1 关键发展阶段
- **1969**：ARPANET诞生（4节点）
- **1974**：TCP/IP架构提出（Cerf & Kahn）
- **1983**：TCP/IP成为标准协议
- **1991**：WWW正式发布（Tim Berners-Lee）
- **1994**：Netscape浏览器推动Web普及
- **2005+**：移动互联网时代（4G/5G, 智能手机）
- **2010+**：云计算与SDN革命

### 1.8.2 重要技术里程碑
- **1988**：TCP拥塞控制算法
- **1998**：Google搜索引擎诞生
- **2004**：Facebook开启社交网络时代
- **2006**：AWS推出云计算服务
- **2007**：iPhone重新定义移动互联网
- **2012**：软件定义网络（SDN）商用化

## 附录：重点概念对比

### 延迟类型对比
| 延迟类型   | 影响因素               | 典型值范围        |
|--------|--------------------|--------------|
| 传输延迟 | 数据包大小、链路带宽       | 1μs-100ms    |
| 传播延迟 | 物理距离、介质传播速度      | 1ms-300ms    |
| 处理延迟 | 路由器处理能力          | <1μs         |
| 排队延迟 | 流量强度、缓冲区大小       | 0-数秒        |

### 安全攻击对比
| 攻击类型 | 攻击层级    | 检测难度 | 危害程度 |
|------|---------|------|------|
| 嗅探   | 链路层     | 高    | 中    |
| DDoS | 网络层     | 中    | 高    |
| XSS  | 应用层     | 低    | 高    |
| MITM | 传输层     | 高    | 极高   |


# 第二章 应用层


## 2.1 应用层核心概念

### 2.1.1 网络应用架构模式
- **客户端-服务器模型**：
  - **服务器**：常驻主机，固定IP，部署于数据中心（支持横向扩展）。
  - **客户端**：间歇性连接，动态IP，不直接互连（如HTTP、FTP）。
- **P2P架构**：
  - 无中心服务器，节点互为客户端/服务器（如BitTorrent）。
  - 优点：自扩展性（节点增加提升服务能力）、抗单点故障。
  - 挑战：动态IP、连接不稳定、管理复杂度高。

### 2.1.2 进程通信与套接字
- **进程标识**：由IP地址+端口号唯一确定（如HTTP-80、SMTP-25）。
- **套接字（Socket）**：
  - 进程间通信的“门”，操作系统控制底层传输，开发者控制应用逻辑。
  - 类比：发送进程将消息“推出门”，传输层负责跨网络投递到接收进程的“门”。

### 2.1.3 应用层协议设计要素
- **消息类型**：请求/响应（如HTTP GET/200 OK）。
- **消息格式**：
  - 语法：字段定义与分隔符（如HTTP头部的`\r\n`）。
  - 语义：字段含义（如`Content-Type: text/html`）。
- **开放与私有协议**：
  - 开放协议（RFC标准）：HTTP、SMTP（支持互操作性）。
  - 私有协议：Skype、Zoom（封闭实现）。

---

## 2.2 HTTP协议深度解析

### 2.2.1 连接管理
- **非持久连接（HTTP 1.0）**：
  - 每个对象需单独建立TCP连接，延迟公式：`2RTT + 传输时间`。
  - 缺点：高延迟（多次握手）、资源浪费（TCP连接开销）。
- **持久连接（HTTP 1.1）**：
  - 单TCP连接传输多个对象，支持流水线请求，减少RTT至1次。
  - 优势：降低延迟、节省带宽。

### 2.2.2 HTTP消息结构
- **请求消息**：
  ```http
  GET /index.html HTTP/1.1
  Host: www.example.com
  User-Agent: Mozilla/5.0
  Accept-Language: en-US
  ```
  - 方法：GET（获取资源）、POST（提交数据）、HEAD（获取头部）、PUT（上传文件）。
- **响应消息**：
  ```http
  HTTP/1.1 200 OK
  Content-Type: text/html
  Content-Length: 1234
  ```
  - 状态码：200（成功）、301（永久重定向）、400(请求错误)、404（未找到）、500（服务器错误）。

### 2.2.3 状态管理：Cookie机制
- **工作原理**：
  1. 服务器通过`Set-Cookie`头部下发唯一标识。
  2. 客户端后续请求携带`Cookie`头部，服务器识别用户状态。
- **应用场景**：
  - 会话管理（如登录状态）、个性化推荐、购物车。
- **隐私争议**：
  - 第一方Cookie：站点自身使用（如用户偏好）。
  - 第三方Cookie：跨站跟踪（如广告联盟），Chrome 2023后默认禁用。

### 2.2.4 性能优化：Web缓存
- **缓存工作流程**：
  1. 客户端请求先发送至缓存服务器。
  2. 命中缓存则直接返回，否则向源服务器请求并缓存。
- **优势**：
  - 降低延迟（缓存靠近客户端）。
  - 减少带宽消耗（如企业节省出口流量）。
- **条件GET**：
  - 客户端发送`If-Modified-Since`头部，若资源未修改，服务器返回`304 Not Modified`，避免重复传输。

### 2.2.5 HTTP演进：HTTP/2与HTTP/3
- **HTTP/2核心改进**：
  - 多路复用：帧（Frame）化传输，解决队头阻塞（HOL Blocking）。
  - 头部压缩：HPACK算法减少冗余。
  - 服务器推送：主动推送关联资源（如CSS/JS）。
- **HTTP/3革新**：
  - 基于QUIC协议（UDP+ TLS 1.3），实现0-RTT连接、独立流控。
  - 解决TCP重传阻塞问题，提升移动网络性能。

---

## 2.3 电子邮件系统

### 2.3.1 核心组件
- **用户代理（UA）**：Outlook、Gmail客户端，负责邮件编辑、发送、接收。
- **邮件服务器**：存储用户邮箱，使用SMTP协议传输邮件。
- **协议栈**：SMTP（发件）、IMAP/POP3（收件）、HTTP（Web邮箱）。

### 2.3.2 SMTP协议详解
- **工作流程**：
  1. 客户端（发送服务器）通过TCP 25端口连接接收服务器。
  2. 命令交互：`HELO`握手 → `MAIL FROM`/`RCPT TO`指定收发方 → `DATA`传输内容。
- **特点**：
  - 推模式（Push），使用7-bit ASCII编码，支持持久连接。
  - 与HTTP对比：无状态 vs 有状态（SMTP需维护会话）。

### 2.3.3 邮件访问协议
- **POP3**：简单下载删除模型，适合单设备访问。
- **IMAP**：在服务器管理文件夹，支持多设备同步（如已读状态）。
- **WebMail**：基于HTTP的图形界面（如Gmail），底层仍依赖SMTP/IMAP。

---

### 附录：关键协议对比表

| 协议    | 端口  | 传输层 | 特性                               | 典型应用         |
|---------|-------|--------|------------------------------------|------------------|
| HTTP    | 80    | TCP    | 无状态、请求-响应                 | 网页浏览         |
| HTTPS   | 443   | TCP    | HTTP + TLS加密                     | 安全交易         |
| SMTP    | 25    | TCP    | 文本推模式、持久连接              | 邮件发送         |
| IMAP    | 143   | TCP    | 服务器管理邮件、多设备同步        | 邮件接收（多端） |
| DNS     | 53    | UDP/TCP| 域名解析、缓存机制                | 地址查询         |

---

## 2.4 DNS：域名系统

### 2.4.1 DNS核心功能
- **域名解析**：将主机名（如`www.example.com`）转换为IP地址（如`192.0.2.1`）。
- **反向解析**：通过IP地址查询域名。
- **服务类型支持**：
  - **主机别名**：一个域名可映射多个别名（如`mail.example.com`作为`example.com`的邮件服务器）。
  - **负载均衡**：一个域名对应多个IP地址，实现流量分发。
  - **邮件服务器定位**：通过MX记录指定邮件服务器地址。

### 2.4.2 DNS层次化架构
- **根域名服务器**：全球13组逻辑根服务器（实际数百台物理服务器），负责TLD服务器地址查询。
- **顶级域名（TLD）服务器**：管理`.com`、`.org`、`.edu`等通用顶级域及国家代码顶级域（如`.cn`）。
- **权威域名服务器**：存储特定域名的资源记录（如`example.com`的DNS服务器）。
- **本地DNS服务器**：由ISP或组织提供，缓存近期查询结果，减少根服务器负载。

### 2.4.3 DNS查询类型
- **迭代查询**：
  - 本地DNS服务器依次向根、TLD、权威服务器查询。
  - 示例：`client → local DNS → root → .com TLD → example.com权威`。
- **递归查询**：
  - 本地DNS代理客户端完成所有查询步骤。
  - 对根和TLD服务器负载较大，较少使用。

### 2.4.4 DNS资源记录类型
| 类型   | 描述                          | 示例                                 |
|--------|-------------------------------|--------------------------------------|
| A      | IPv4地址记录                  | `www.example.com → 192.0.2.1`       |
| AAAA   | IPv6地址记录                  | `www.example.com → 2001:db8::1`     |
| CNAME  | 别名记录                      | `mail.example.com → example.com`    |
| MX     | 邮件服务器记录                | `example.com → mail.example.com`    |
| NS     | 指定域名的权威服务器          | `example.com → ns1.example.com`     |
| TXT    | 文本信息（如SPF、DKIM验证）   | `"v=spf1 include:_spf.example.com"` |

### 2.4.5 DNS安全与挑战
- **DDoS攻击**：针对根或TLD服务器的大流量攻击，通过本地缓存缓解。
- **DNS欺骗（缓存投毒）**：伪造DNS响应，引导用户至恶意IP。
- **DNSSEC**：通过数字签名验证数据来源，防止篡改（RFC 4033）。

---

## 2.5 P2P网络与文件分发

### 2.5.1 P2P架构特点
- **去中心化**：无固定服务器，节点互为客户端和服务器。
- **自扩展性**：节点加入提升系统整体服务能力。
- **动态性**：节点可随时加入/离开，IP地址可变。

### 2.5.2 BitTorrent协议机制
- **核心组件**：
  - **种子文件（.torrent）**：包含Tracker URL和文件分块哈希。
  - **Tracker服务器**：协调节点列表，不参与数据传输。
  - **Swarm**：参与同一文件分发的节点集合。
- **分块传输策略**：
  - **最稀有优先（Rarest First）**：优先下载稀缺分块，提高系统冗余。
  - **Tit-for-Tat**：节点优先服务上传速率高的对等方。
  - **乐观疏通（Optimistic Unchoking）**：随机选择节点上传，防止资源垄断。

### 2.5.3 P2P与C/S模型对比
| 指标         | 客户端-服务器模型               | P2P模型                              |
|--------------|---------------------------------|--------------------------------------|
| 扩展性       | 服务器带宽成为瓶颈              | 节点越多，分发能力越强                |
| 成本         | 服务器维护成本高                | 基础设施成本低                        |
| 可靠性       | 单点故障风险                    | 高冗余，抗节点失效                    |
| 适用场景     | 小规模、静态内容                | 大规模分发（如Linux镜像、视频）       |

---

## 2.6 流媒体与内容分发网络（CDN）

### 2.6.1 视频流技术基础
- **编码与压缩**：
  - **空间冗余**：单帧内相似区域压缩（如JPEG）。
  - **时间冗余**：连续帧间差异编码（如MPEG）。
- **传输协议**：
  - **DASH（Dynamic Adaptive Streaming）**：客户端动态选择视频质量，基于带宽变化调整。
  - **HLS（HTTP Live Streaming）**：苹果公司标准，将视频切分为TS分片，通过M3U8索引。

### 2.6.2 CDN架构与策略
- **内容缓存策略**：
  - **拉取式（Pull）**：按需缓存，适合长尾内容。
  - **推送式（Push）**：预分发热门内容至边缘节点。
- **节点部署模式**：
  - **Enter Deep**：深入ISP网络（如Akamai），减少延迟。
  - **Bring Home**：在互联网交换点（IXP）部署（如Cloudflare）。

### 2.6.3 Netflix案例
- **Open Connect CDN**：
  - 自建CDN节点，与ISP合作部署。
  - 用户请求通过ISP本地节点直接获取内容，降低骨干网压力。
- **视频分发流程**：
  1. 用户请求视频，DNS返回最近的CDN节点。
  2. 客户端下载Manifest文件，选择最佳质量分片。
  3. 分片通过HTTP范围请求（Range Request）传输。

---

## 2.7 Socket编程基础

### 2.7.1 UDP与TCP对比
| 特性               | UDP                                  | TCP                                  |
|--------------------|--------------------------------------|--------------------------------------|
| 连接方式           | 无连接                               | 面向连接                             |
| 可靠性             | 不保证顺序和到达                     | 可靠传输，有序                       |
| 头部开销           | 8字节                                | 20字节                               |
| 适用场景           | 实时音视频、DNS查询                  | 文件传输、网页浏览                   |

### 2.7.2 关键API函数
- **UDP通信流程**：
  ```c
  // 服务器端
  socket(AF_INET, SOCK_DGRAM, 0);
  bind(sock, (struct sockaddr*)&addr, sizeof(addr));
  recvfrom(sock, buffer, len, 0, &client_addr, &addr_len);
  sendto(sock, data, len, 0, &client_addr, addr_len);

  // 客户端
  sendto(sock, data, len, 0, &server_addr, sizeof(server_addr));
  recvfrom(sock, buffer, len, 0, NULL, NULL);
  ```

- **TCP通信流程**：
  ```c
  // 服务器端
  listen(sock, backlog);
  accept(sock, &client_addr, &addr_len);  // 阻塞等待连接
  send(new_sock, data, len, 0);
  recv(new_sock, buffer, len, 0);

  // 客户端
  connect(sock, &server_addr, sizeof(server_addr));
  send(sock, data, len, 0);
  recv(sock, buffer, len, 0);
  ```

### 2.7.3 地址结构体
- **IPv4地址表示**：
  ```c
  struct sockaddr_in {
      sa_family_t    sin_family;   // AF_INET
      in_port_t      sin_port;     // 端口号（网络字节序）
      struct in_addr sin_addr;     // IPv4地址
  };

  struct in_addr {
      uint32_t s_addr;             // 32位IP地址（网络字节序）
  };
  ```

---

### 附录：关键协议端口号速查表

| 协议   | 端口号 | 传输层协议 | 用途               |
|--------|--------|------------|--------------------|
| HTTP   | 80     | TCP        | 网页传输           |
| HTTPS  | 443    | TCP        | 加密HTTP           |
| DNS    | 53     | UDP/TCP    | 域名解析           |
| SMTP   | 25     | TCP        | 邮件发送           |
| IMAP   | 143    | TCP        | 邮件管理           |
| SSH    | 22     | TCP        | 安全远程登录       |
| FTP    | 21     | TCP        | 文件传输控制       |



# 第三章 传输层


## 3.1 传输层核心功能

### 3.1.1 传输层与网络层的关系
- **网络层**：负责主机到主机的通信（如IP协议）。
- **传输层**：负责进程到进程的通信（如TCP/UDP），通过端口号标识应用进程。
- **核心服务**：
  - **多路复用/分解**：将多个应用进程的数据通过不同端口区分。
  - **可靠性**：确保数据完整、有序传输（TCP）。
  - **流量控制**：防止发送方压垮接收方（TCP滑动窗口）。
  - **拥塞控制**：避免网络过载（TCP拥塞控制算法）。

---

## 3.2 多路复用与分解
### 3.2.1 多路复用（Multiplexing）
- **定义**：将多个应用进程的数据合并到单一网络层数据流中。
- **实现方式**：通过添加传输层头部（含端口号）区分不同应用。

### 3.2.2 分解（Demultiplexing）
- **定义**：将接收到的数据分发到正确的目标应用进程。
- **关键字段**：
  - **UDP**：仅使用目标端口号进行分解。
  - **TCP**：使用四元组（源IP、源端口、目标IP、目标端口）进行分解。

| 协议 | 分解依据                     | 特点                     |
|------|------------------------------|--------------------------|
| UDP  | 目标端口号                   | 无连接，同一端口接收所有源数据 |
| TCP  | 源IP、源端口、目标IP、目标端口 | 面向连接，每个连接独立处理 |

---

## 3.3 无连接传输：UDP
### 3.3.1 UDP核心特点
- **无连接**：无需建立连接，直接发送数据。
- **不可靠性**：不保证数据到达、顺序或完整性。
- **高效性**：头部开销小（8字节），无拥塞控制，适合实时应用。

### 3.3.2 UDP段格式
```plaintext
 0               16              31
+----------------+----------------+
|   源端口号     |   目标端口号    |
+----------------+----------------+
|     长度       |    校验和       |
+----------------+----------------+
|           应用数据（载荷）       |
+----------------------------------+
```
- **长度**：UDP段总长度（包括头部）。
- **校验和**：检测数据传输中的错误（16位反码和）。

### 3.3.3 UDP适用场景
- **实时流媒体**：如视频会议（容忍丢包，低延迟优先）。
- **DNS查询**：短小请求/响应，无需连接建立。
- **SNMP监控**：周期性状态报告，偶发丢包可接受。
- **HTTP/3**：基于UDP实现可靠传输，优化Web性能。

---

## 3.4 可靠数据传输原理
### 3.4.1 基本概念
- **可靠信道抽象**：数据不丢失、不重复、按序到达。
- **实现挑战**：网络层不可靠（丢包、乱序、错误）。

### 3.4.2 可靠数据传输协议（rdt）
1. **rdt1.0**：理想信道（无错误）。
2. **rdt2.0**：引入错误检测（校验和）与确认（ACK/NAK）。
3. **rdt2.1**：处理ACK/NAK丢失（序列号机制）。
4. **rdt3.0**：增加超时重传，解决丢包问题。

### 3.4.3 有限状态机（FSM）示例
- **发送方状态**：
  - **等待上层调用**：接收应用数据，发送分组。
  - **等待ACK**：启动定时器，超时重传。
- **接收方状态**：
  - **等待分组0**：接收并检查序列号，发送ACK0。
  - **等待分组1**：接收并检查序列号，发送ACK1。

---

## 3.5 校验和机制详解
### 3.5.1 校验和计算步骤
1. **数据分块**：将数据分为16位整数序列。
2. **反码求和**：累加所有整数，溢出位回卷。
3. **取反码**：结果取反作为校验和。

**示例**：
- 数据：`0b1110011001100110` 和 `0b1101010101010101`
- 求和：`0xE666 + 0xD555 = 0x1BBBB` → 溢出后为 `0xBBBC`
- 校验和：`0x4443`（取反）

### 3.5.2 校验和局限性
- **无法检测所有错误**：如多位同时翻转可能校验和不变。
- **弱保护性**：仅用于错误检测，无法纠正错误。

---

## 3.6 传输层关键协议对比
| 特性         | UDP                            | TCP                            |
|--------------|--------------------------------|--------------------------------|
| **连接类型** | 无连接                         | 面向连接                       |
| **可靠性**   | 不可靠                         | 可靠（确认、重传、有序）       |
| **头部开销** | 8字节                         | 20字节（基础）                 |
| **速度**     | 快（无握手、无拥塞控制）       | 慢（连接管理、拥塞控制）       |
| **适用场景** | 实时应用、短查询               | 文件传输、Web页面加载          |

---

## 附录：关键术语速查表
| 术语               | 定义                                                                 |
|--------------------|----------------------------------------------------------------------|
| 多路复用           | 合并多个数据流到单一网络层通道                                       |
| 分解               | 将接收的数据分发到目标应用进程                                       |
| 校验和             | 用于检测数据传输错误的计算值                                         |
| 有限状态机（FSM） | 描述协议状态转换的模型，包含状态、事件、动作                         |
| 超时重传           | 发送方在未收到确认时重新发送数据                                     |
| 滑动窗口           | TCP流量控制机制，动态调整可发送数据量                                |



---

## 3.7 可靠数据传输协议（RDT）演进
### 3.7.1 RDT1.0：理想信道模型
- **假设**：信道完全可靠（无丢包、无错误）。
- **机制**：
  - 发送方直接发送数据，接收方直接接收。
  - 无错误检测、重传机制。
- **局限性**：仅适用于理论场景，无法处理实际网络问题。

### 3.7.2 RDT2.0：处理位错误
- **新增功能**：
  - **校验和（Checksum）**：检测数据错误（如16位反码和）。
  - **确认（ACK）与否定确认（NAK）**：接收方反馈是否成功接收。
  - **停等协议（Stop-and-Wait）**：发送方每发送一个包后等待确认。
- **状态机**：
  - **发送方**：等待上层数据 → 发送包 → 等待ACK/NAK。
  - **接收方**：接收包 → 检查错误 → 发送ACK/NAK。
- **问题**：ACK/NAK本身可能损坏，导致发送方无法确认状态。

### 3.7.3 RDT2.1：引入序列号
- **改进**：添加1位序列号（0或1）区分新旧包。
  - 发送方重传时携带相同序列号，接收方丢弃重复包。
- **状态机扩展**：
  - 发送方和接收方需维护当前序列号状态。
  - 处理ACK/NAK损坏时，通过序列号避免歧义。

### 3.7.4 RDT2.2：无NAK协议
- **改进**：仅使用ACK，接收方通过重复ACK（如ACK1）隐式指示错误。
  - 发送方收到重复ACK时重传数据。
- **优势**：简化协议设计，减少控制消息类型。

### 3.7.5 RDT3.0：处理丢包问题
- **新增机制**：超时重传。
  - **定时器**：发送方为每个包启动定时器，超时未收到ACK则重传。
  - **序列号扩展**：仍使用1位序列号，但通过超时机制处理丢包。
- **状态机**：
  - 发送方在等待ACK时启动定时器，超时后重传并重置定时器。
  - 接收方通过序列号过滤重复包。

---

## 3.8 流水线协议：提升效率
### 3.8.1 停等协议的性能瓶颈
- **信道利用率低**：发送方在RTT（往返时间）内仅发送一个包。
  - **公式**：利用率 $U = \frac{L/R}{RTT + L/R}$（$L$为包大小，$R$为链路速率）。
  - **示例**：1Gbps链路，8000bit包，RTT=30ms → 利用率仅0.027%。

### 3.8.2 回退N步（Go-Back-N, GBN）
- **核心思想**：允许发送方连续发送多个包（窗口大小N），累积确认。
- **机制**：
  - **发送方**：
    - 维护发送窗口（当前可发送的包范围）。
    - 超时重传所有未确认包（从最早未确认包开始）。
  - **接收方**：
    - 仅按序接收，丢弃乱序包。
    - 发送最高按序包的ACK（如ACK3表示0-3已接收）。
- **示例**：窗口大小N=4，丢包2时，发送方重传2、3、4、5。

### 3.8.3 选择性重传（Selective Repeat, SR）
- **核心思想**：接收方缓存乱序包，发送方仅重传丢失包。
- **机制**：
  - **发送方**：为每个包维护独立定时器，超时重传单个包。
  - **接收方**：
    - 确认所有正确接收的包（包括乱序包）。
    - 按序交付数据，窗口滑动到第一个未接收包。
- **窗口设计**：
  - **序列号空间**：窗口大小需满足 $\text{序列号范围} \geq 2 \times \text{窗口大小}$，避免歧义（如窗口3需至少7个序列号）。

---

## 3.9 协议对比与应用场景
| **协议** | **确认机制**       | **重传策略**         | **接收方处理**       | **适用场景**               |
|----------|--------------------|----------------------|----------------------|----------------------------|
| GBN      | 累积确认（ACK n）  | 重传所有未确认包     | 丢弃乱序包           | 低延迟网络，容忍重复开销   |
| SR       | 独立确认（每个包） | 仅重传丢失包         | 缓存乱序包           | 高带宽网络，减少重传浪费   |
| RDT3.0   | 停等确认           | 超时重传单个包       | 按序接收，无缓存     | 简单低负载环境             |

---

## 3.10 关键问题与解决方案
1. **ACK/NAK损坏**：
   - **RDT2.1**：引入序列号，通过重复包检测避免歧义。
2. **丢包处理**：
   - **RDT3.0**：超时重传，定时器设置需大于RTT。
3. **流水线效率**：
   - **GBN/SR**：通过窗口机制提升信道利用率，GBN适合低乱序率，SR适合高乱序率。
4. **序列号空间设计**：
   - **SR协议**：序列号范围需为窗口大小的两倍，防止新旧包混淆（如窗口3需序列号0-6）。

---

## 附录：术语速查表
| **术语**         | **定义**                                                                 |
|------------------|-------------------------------------------------------------------------|
| 累积确认（ACK n）| 表示所有≤n的包已正确接收                                               |
| 选择确认（SACK） | 显式确认非连续接收的包（需扩展协议支持）                                |
| 滑动窗口         | 动态调整发送/接收窗口范围，平衡吞吐量与资源占用                         |
| 超时重传         | 定时器触发后重传未确认包，解决丢包问题                                  |



---

## 3.11 TCP协议核心机制
### 3.11.1 TCP段结构
```plaintext
 0               16              31
+----------------+----------------+
|   源端口号     |   目标端口号    |
+----------------+----------------+
|     序列号（SEQ）                |
+----------------------------------+
|     确认号（ACK）                |
+----------------+----------------+
| 首部长度 | 保留 |控制位|  窗口大小  |
+----------------+----------------+
|    校验和       |  紧急指针      |
+----------------+----------------+
|           选项（可选）           |
+----------------------------------+
|             数据载荷              |
+----------------------------------+
```
- **关键字段**：
  - **序列号（SEQ）**：数据流中第一个字节的编号（32位，循环计数）。
  - **确认号（ACK）**：期望接收的下一个字节编号（累积确认）。
  - **窗口大小（Window）**：接收方可用缓冲区大小（流量控制）。
  - **控制位**：SYN（建立连接）、ACK（确认）、FIN（终止连接）、RST（重置连接）等。

### 3.11.2 可靠数据传输机制
1. **序列号与确认机制**：
   - 每个数据字节分配唯一序列号，接收方通过ACK确认连续接收的数据。
   - **累积确认**：ACK(n)表示所有≤n的字节已正确接收。
2. **超时重传**：
   - **估计RTT**：通过指数加权移动平均（EWMA）计算：
     $$
     \text{EstimatedRTT} = (1-\alpha) \cdot \text{EstimatedRTT} + \alpha \cdot \text{SampleRTT} \quad (\alpha=0.125)
     $$
   - **超时间隔**：考虑RTT波动，加入安全边际：
     $$
     \text{TimeoutInterval} = \text{EstimatedRTT} + 4 \cdot \text{DevRTT}
     $$
3. **快速重传**：
   - 收到3个重复ACK时（如ACK=100重复3次），立即重传丢失段，无需等待超时。

---

## 3.12 TCP流量控制
### 3.12.1 滑动窗口机制
- **接收窗口（rwnd）**：接收方通过TCP头部通告可用缓冲区大小。
  - 发送方限制未确认数据量不超过rwnd，避免接收方溢出。
- **动态调整**：
  - 接收方根据应用读取速度更新rwnd。
  - 发送方通过ACK中的窗口字段调整发送速率。

**示例**：
- 接收方缓冲区大小为10KB，已接收5KB未读取 → rwnd=5KB。
- 发送方最多发送5KB未确认数据。

### 3.12.2 零窗口与持续计时器
- **零窗口**：接收方rwnd=0时，发送方暂停发送。
- **持续计时器**：定期发送探测段（1字节数据），避免死锁。

---

## 3.13 TCP连接管理
### 3.13.1 三次握手（建立连接）
1. **SYN**：客户端发送SYN段（SEQ=x，SYN=1）。
2. **SYN-ACK**：服务端回应SYN-ACK（SEQ=y，ACK=x+1，SYN=1，ACK=1）。
3. **ACK**：客户端确认（ACK=y+1，ACK=1），连接建立（ESTABLISHED）。

**状态机**：
```plaintext
客户端: CLOSED → SYN_SENT → ESTABLISHED
服务端: LISTEN → SYN_RCVD → ESTABLISHED
```

### 3.13.2 四次挥手（终止连接）
1. **FIN**：主动关闭方发送FIN段（FIN=1）。
2. **ACK**：接收方确认FIN。
3. **FIN**：接收方发送FIN段。
4. **ACK**：主动关闭方确认，进入TIME_WAIT（等待2MSL防止旧报文干扰）。

**状态机**：
```plaintext
主动方: ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
被动方: ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
```

---

## 3.14 TCP拥塞控制
### 3.14.1 拥塞控制原理
- **目标**：避免网络过载，平衡吞吐量与延迟。
- **与流量控制的区别**：
  | **特性**       | **拥塞控制**               | **流量控制**               |
  |----------------|----------------------------|----------------------------|
  | 控制对象        | 网络全局资源                | 接收方缓冲区               |
  | 触发条件        | 丢包、延迟增加              | 接收方窗口减少             |
  | 实现机制        | AIMD、慢启动等              | 滑动窗口、零窗口探测        |

### 3.14.2 核心算法
1. **慢启动（Slow Start）**：
   - 初始cwnd=1 MSS，每RTT翻倍（指数增长）。
   - 触发切换：cwnd≥ssthresh时进入拥塞避免阶段。
2. **拥塞避免（AIMD）**：
   - 每RTT增加1 MSS（线性增长）。
   - 丢包时，ssthresh=cwnd/2，cwnd=1 MSS（超时）或cwnd=ssthresh（快速恢复）。
3. **快速恢复**：
   - 收到3个重复ACK时，cwnd=ssthresh+3，重传丢失段。

**拥塞控制状态机**：
```plaintext
慢启动 → (cwnd≥ssthresh) → 拥塞避免
丢包（超时）→ 慢启动
丢包（3 DupACK）→ 快速恢复 → 拥塞避免
```

---

## 3.15 高级主题与协议演进
### 3.15.1 显式拥塞通知（ECN）
- **机制**：路由器标记IP头部ECN位，接收方通过TCP ACK反馈拥塞。
  - ECN=11（拥塞经历），ECE=1（ECN-Echo）。
- **优势**：提前预警，避免丢包导致的吞吐量骤降。

### 3.15.2 QUIC协议
- **基于UDP**：解决TCP队头阻塞（HOL Blocking），支持多独立流。
- **特性**：
  - 0-RTT连接建立（复用先前会话密钥）。
  - 内置加密（TLS 1.3），头部保护。
  - 前向纠错（FEC）减少重传。
- **应用**：HTTP/3标准，优化Web性能。

---

## 3.16 关键公式与性能指标
1. **吞吐量公式**：
   $$
   \text{Throughput} \approx \frac{\text{cwnd}}{\text{RTT}}
   $$
2. **理想拥塞控制吞吐量**（Mathis公式）：
   $$
   \text{Throughput} = \frac{1.22 \cdot \text{MSS}}{\text{RTT} \cdot \sqrt{L}} \quad (L=\text{丢包率})
   $$

---

### 总结与重点
- **必考知识点**：
  - TCP三次握手/四次挥手流程及状态转换。
  - 滑动窗口机制与流量控制。
  - 拥塞控制算法（慢启动、AIMD、快速恢复）。
- **常见问题**：
  - 如何区分流量控制与拥塞控制？
  - 快速重传为何设置为3个重复ACK？
  - QUIC相比TCP的优势有哪些？


### 参考答案


#### **1. TCP三次握手/四次挥手流程及状态转换**

##### **三次握手（建立连接）**
1. **流程**：
   - **SYN**：客户端发送SYN段（`SYN=1, SEQ=x`）→ 进入`SYN_SENT`状态。
   - **SYN-ACK**：服务端回复SYN-ACK（`SYN=1, ACK=1, SEQ=y, ACKnum=x+1`）→ 进入`SYN_RCVD`状态。
   - **ACK**：客户端发送ACK（`ACK=1, ACKnum=y+1`）→ 双方进入`ESTABLISHED`状态。

2. **状态转换**：
   - **客户端**：`CLOSED → SYN_SENT → ESTABLISHED`
   - **服务端**：`LISTEN → SYN_RCVD → ESTABLISHED`

##### **四次挥手（关闭连接）**
1. **流程**：
   - **FIN**：主动关闭方发送FIN段（`FIN=1, SEQ=u`）→ 进入`FIN_WAIT_1`状态。
   - **ACK**：接收方回复ACK（`ACK=1, ACKnum=u+1`）→ 进入`CLOSE_WAIT`状态。
   - **FIN**：接收方发送FIN段（`FIN=1, SEQ=v`）→ 进入`LAST_ACK`状态。
   - **ACK**：主动方回复ACK（`ACK=1, ACKnum=v+1`）→ 进入`TIME_WAIT`（等待2MSL后`CLOSED`）。

2. **状态转换**：
   - **主动方**：`ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED`
   - **被动方**：`ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED`

---

#### **2. 滑动窗口机制与流量控制**

##### **滑动窗口**
- **发送窗口**：允许发送但未确认的字节范围（`[LastByteAcked, LastByteSent]`）。
- **接收窗口（rwnd）**：接收方通过TCP头部通告的可用缓冲区大小。
- **动态调整**：
  - 发送方根据`rwnd`调整发送速率，确保未确认数据量不超过窗口大小。
  - **零窗口**：当`rwnd=0`时，发送方暂停发送，并通过持续计时器探测窗口恢复。

##### **流量控制**
- **目标**：防止发送方压垮接收方（点对点问题）。
- **实现**：
  - 接收方通过ACK中的`rwnd`字段动态通告剩余缓冲区。
  - 发送方维护`cwnd`（拥塞窗口）和`rwnd`的最小值作为实际发送窗口。

---

#### **3. 拥塞控制算法（慢启动、AIMD、快速恢复）**

##### **慢启动（Slow Start）**
- **触发**：连接建立或超时后。
- **规则**：
  - 初始`cwnd=1 MSS`，每收到一个ACK，`cwnd += 1 MSS`（指数增长）。
  - 当`cwnd ≥ ssthresh`（默认65535字节）时，进入拥塞避免阶段。

##### **拥塞避免（AIMD）**
- **规则**：
  - 每RTT增加`1 MSS`（线性增长）。
  - **丢包处理**：
    - **超时**：`ssthresh = cwnd/2`，`cwnd=1 MSS`，重启慢启动。
    - **3 DupACK**：触发快速重传，进入快速恢复。

##### **快速恢复（Fast Recovery）**
- **触发**：收到3个重复ACK。
- **规则**：
  - `ssthresh = cwnd/2`，`cwnd = ssthresh + 3`。
  - 每收到重复ACK，`cwnd += 1 MSS`（快速填充管道）。
  - 收到新ACK后，`cwnd = ssthresh`，进入拥塞避免。



---

#### **1. 如何区分流量控制与拥塞控制？**

| **特征**         | **流量控制**                     | **拥塞控制**                     |
|------------------|----------------------------------|----------------------------------|
| **目标**         | 防止接收方缓冲区溢出             | 防止网络过载                     |
| **触发条件**     | 接收方窗口（rwnd）不足           | 丢包、延迟增加                   |
| **控制对象**     | 点对点（发送方与接收方）          | 全局网络资源                     |
| **实现机制**     | 滑动窗口动态调整发送速率          | AIMD算法（慢启动、拥塞避免等）   |
| **调整参数**     | 接收方通告的rwnd                 | 发送方维护的cwnd                 |

**示例**：
- **流量控制**：接收方处理慢，发送方根据`rwnd=0`暂停发送。
- **拥塞控制**：网络路由器丢包，发送方通过`cwnd`减少发送速率。

---

#### **2. 快速重传为何设置为3个重复ACK？**

- **避免误判**：网络可能存在包乱序（如路径不同），少量重复ACK（如1-2个）可能是乱序而非丢包。
- **平衡效率**：3次重复ACK是经验值，既减少误判概率，又避免过晚触发重传。
- **RFC标准**：TCP协议规定3个重复ACK作为丢包标志，触发快速重传。

**示例**：
- 发送方发送SEQ=100、200、300的包，若SEQ=200丢失：
  - 接收方收到SEQ=300会回复ACK=200（重复3次）。
  - 发送方确认SEQ=200丢失，立即重传。

---

#### **3. QUIC相比TCP的优势有哪些？**

| **优势**         | **QUIC**                          | **TCP**                          |
|------------------|------------------------------------|----------------------------------|
| **传输层协议**   | 基于UDP，绕过中间设备限制          | 基于IP，易受NAT/防火墙限制        |
| **队头阻塞**     | 多路复用独立流，无队头阻塞         | 单流，队头阻塞影响性能           |
| **连接建立**     | 0-RTT/1-RTT握手（复用先前会话）    | 3次握手（至少1-RTT）             |
| **加密**         | 内置TLS 1.3，强制加密              | 可选TLS，需额外握手               |
| **拥塞控制**     | 灵活，支持多种算法（如BBR）        | 固定AIMD，调整不灵活             |
| **移动网络优化** | 连接迁移（IP变化不影响会话）       | 依赖IP，切换网络需重建连接        |

**示例**：
- **HTTP/3**：基于QUIC实现，网页加载速度提升20%-30%（尤其在丢包率高时）。
- **视频会议**：QUIC多路复用避免音频/视频流相互阻塞。

---

#### 总结与记忆技巧

- **三次握手**：SYN → SYN-ACK → ACK（“你好→你好吗→我很好”）。
- **四次挥手**：FIN → ACK → FIN → ACK（“再见→好的→再见→好的”）。
- **滑动窗口**：想象一个可伸缩的传送带，根据接收方空间调整输送量。
- **拥塞控制**：慢启动如踩油门起步，拥塞避免如匀速行驶，快速恢复如紧急刹车后缓慢加速。
- **QUIC优势**：0-RTT、多流、无阻塞、强加密，适合现代网络需求。




















